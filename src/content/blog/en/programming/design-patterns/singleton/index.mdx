---
title: "Singleton Pattern in TypeScript"
description: "Learn what the Singleton pattern is, how to implement it in TypeScript, its advantages, disadvantages, and modern alternatives for managing global instances."
pubDate: "2025-01-25"
category: "design-patterns"
subcategory: "creational"
tags: ["design-patterns", "singleton", "typescript", "creational", "oop"]
heroImage: "./hero.jpg"
draft: false
---

import CodePlayground from '../../../../../../components/CodePlayground.astro';

The **Singleton pattern** is one of the most well-known and used design patterns in object-oriented programming. It belongs to the category of **creational patterns**, as it focuses on how objects are instantiated.

## What is the Singleton Pattern?

The Singleton pattern ensures that **a class has only one instance** and provides **a global access point** to that instance. This means that no matter how many times we try to instantiate the class, we will always get the same object.

### Real-World Example

Imagine a single printer in an office. All employees need to use it, but there's only one physical device. The Singleton pattern emulates this behavior: no matter how many times someone requests "the printer", they will always get the same instance.

## Basic Structure

The Singleton pattern has three fundamental characteristics:

1. **Private constructor**: Prevents external instantiation of the class
2. **Static instance**: Stores the single instance of the class
3. **Static access method**: Provides the only way to obtain the instance

## Implementation in TypeScript

### Basic Example

```typescript
class Singleton {
  private static instance: Singleton;

  // Private constructor prevents external instantiation
  private constructor() {
    console.log("Creating unique instance...");
  }

  // Static method to get the instance
  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  public someMethod(): void {
    console.log("Executing method from Singleton");
  }
}

// Usage
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // true
instance1.someMethod();
```

### Practical Example: Configuration Manager

A common case is using Singleton to manage application configuration:

```typescript
interface AppConfig {
  apiUrl: string;
  timeout: number;
  retries: number;
}

class ConfigurationManager {
  private static instance: ConfigurationManager;
  private config: AppConfig;

  private constructor() {
    // Load initial configuration
    this.config = {
      apiUrl: "https://api.example.com",
      timeout: 5000,
      retries: 3
    };
  }

  public static getInstance(): ConfigurationManager {
    if (!ConfigurationManager.instance) {
      ConfigurationManager.instance = new ConfigurationManager();
    }
    return ConfigurationManager.instance;
  }

  public getConfig(): AppConfig {
    return { ...this.config }; // Return a copy
  }

  public updateConfig(newConfig: Partial<AppConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }
}

// Usage
const config1 = ConfigurationManager.getInstance();
const config2 = ConfigurationManager.getInstance();

console.log(config1 === config2); // true

config1.updateConfig({ timeout: 10000 });
console.log(config2.getConfig().timeout); // 10000
```

## Thread-Safe Implementation

In multithreaded environments, it's important to ensure that multiple threads cannot create multiple instances. Although JavaScript is single-threaded, it's good to know this concept:

```typescript
class ThreadSafeSingleton {
  private static instance: ThreadSafeSingleton | null = null;
  private static isCreating = false;

  private constructor() {}

  public static getInstance(): ThreadSafeSingleton {
    if (!ThreadSafeSingleton.instance) {
      if (!ThreadSafeSingleton.isCreating) {
        ThreadSafeSingleton.isCreating = true;
        ThreadSafeSingleton.instance = new ThreadSafeSingleton();
        ThreadSafeSingleton.isCreating = false;
      }
    }
    return ThreadSafeSingleton.instance!;
  }
}
```

## Advantages of the Singleton Pattern

1. **Controlled access**: Ensures only one instance exists
2. **Global access**: Easy to access from anywhere in the application
3. **Lazy initialization**: The instance is created only when needed
4. **Resource savings**: Avoids creating multiple instances of heavy objects
5. **State consistency**: All parts of the application share the same state

## Disadvantages and Criticisms

1. **Global state**: Can make testing difficult and create hidden dependencies
2. **Violates Single Responsibility**: The class manages both its logic and its instantiation
3. **Difficult to test**: Complicates unit testing, as state persists between tests
4. **Can hide design problems**: Sometimes used when better architectural solutions exist
5. **Concurrency**: In multithreaded languages, special care is needed

## When to Use Singleton

✅ **Good use cases:**
- Logging systems
- Database connections
- Application configuration
- Cache managers
- Thread pools
- Device drivers

❌ **When NOT to use it:**
- When you need multiple instances in the future
- In classes that should be testable in isolation
- When it can be replaced with dependency injection
- If it generates excessive coupling

## Modern Alternatives

### 1. Dependency Injection

Instead of using Singleton, many modern frameworks use dependency injection:

```typescript
// Instead of Singleton
class Logger {
  constructor(private level: string) {}

  log(message: string): void {
    console.log(`[${this.level}] ${message}`);
  }
}

// Inject the same instance where needed
const logger = new Logger('INFO');
const service1 = new Service(logger);
const service2 = new Service(logger);
```

### 2. ES6 Modules

In JavaScript/TypeScript, modules are natural Singletons:

```typescript
// config.ts
class Config {
  public apiUrl = "https://api.example.com";
  public timeout = 5000;
}

export const config = new Config(); // Natural Singleton

// Usage in other files
import { config } from './config';
```

### 3. Context Pattern (React)

In React, Context provides a way to share data without Singleton:

```typescript
import { createContext, useContext } from 'react';

const ConfigContext = createContext<AppConfig | null>(null);

export const useConfig = () => {
  const config = useContext(ConfigContext);
  if (!config) throw new Error('Config not provided');
  return config;
};
```

## Interactive Example

Try this Singleton implementation in Python:

<CodePlayground
  language="python"
  title="Singleton in Python"
  code={`class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            print("Creating new instance")
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        self.value = 0

    def increment(self):
        self.value += 1
        return self.value

# Test
s1 = Singleton()
s2 = Singleton()

print(f"Are they the same? {s1 is s2}")  # True

s1.increment()
s1.increment()
print(f"s1 value: {s1.value}")  # 2
print(f"s2 value: {s2.value}")  # 2 (same instance!)`}
/>

## Conclusion

The Singleton pattern is a powerful tool when used appropriately. Although it has its critics, it remains useful in specific scenarios where we need to ensure a single instance of a class.

However, it's important to consider modern alternatives like dependency injection or ES6 modules, which can offer more flexible and testable solutions.

**Remember:** Before implementing a Singleton, ask yourself if you really need to restrict instantiation or if there are better architectural alternatives for your case.

## Additional Resources

- [Refactoring Guru - Singleton Pattern](https://refactoring.guru/design-patterns/singleton)
- [TypeScript Official Documentation](https://www.typescriptlang.org/)
- [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)
